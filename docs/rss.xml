<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>ThinkingRocks</title>
        <link>https://aloisrtr.github.io/thinkingrocks</link>
        <description><![CDATA[Blogposts about the endeavours of a computer science student]]></description>
        <atom:link href="https://aloisrtr.github.io/thinkingrocks/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Mon, 12 Feb 2024 00:00:00 UT</lastBuildDate>
        <item>
    <title>Writing an efficient game representation for chess</title>
    <link>https://aloisrtr.github.io/thinkingrocks/posts/2024-02-12-writing-an-efficient-chess-move-generator.html</link>
    <description><![CDATA[<p>I’ve recently (re-)fell in the good old rabbit hole that got me into computer science
in the first place: chess programming.</p>
<p>This is probably my third or fourth rewrite of <a href="https://github.com/aloisrtr/chameleon-chess">chameleon-chess</a>,
except this time I’m pretty happy with the game representation, which was a huge blocking
point for me before. So, as always when I’m happy that something works, I’d like
to write about how!</p>
<!--more-->
<h2 id="whats-a-game-representation-why-do-we-care">What’s a game representation? Why do we care?</h2>
<p>Chess engines (and many board game bots) can be separated into three core components:</p>
<ul>
<li><strong>game representation</strong>, responsible for encoding game state and actions from one state to another.</li>
<li><strong>search algorithms</strong> to find the best action given a game state.</li>
<li><strong>evaluation</strong>, heuristics to guess the probabilities of winning when we’re in a certain state.</li>
</ul>
<p>If you’ve got some knowledge about computer science, a game representation can be thought of
as a really really big directed graphs with an edge from state A to B is there is
an action that can transform A into B when applied.</p>
<figure>
<img src="/files/writing-an-efficient-game-representation-for-chess/chess_tree.png" data-max-height="40em" alt="A really tiny subset of the chess game graph" />
<figcaption aria-hidden="true">A really tiny subset of the chess game graph</figcaption>
</figure>
<blockquote>
<p>Games are often really, <strong>really</strong> big, too big to fit into memory, which is
why we define the graph <em>implicitly</em>.</p>
<p>Some games like tic-tac-toe are small enough to represent entirely in memory, but
since chess has more legal positions than there are atoms in the observable universe,
we might want to avoid trying to do that.</p>
</blockquote>
<p>Game representation is a bit of a sore spot for me. To put it bluntly, it can <strong>break
but not make</strong> your engine.</p>
<p>A bad game representation leads to really poor performance,
yet a good one does not make your engine inherently stronger. This imbalance is caused by the fact
that you rely on game representation to traverse game states, so it need to be
<strong>at least really really efficient</strong>. But you also want to avoid traversing the tree too much,
so the stronger your engine becomes, the less game representation speed is relevant.</p>
<p>Writing an efficient and correct game representation is still <strong>necessary</strong>, and there
aren’t a ton of detailled tutorials on how to do so. Let’s fix that!</p>
<blockquote>
<p>The <a href="https://www.chessprogramming.org">chess programming wiki</a> offers a lot of
information on various techniques used, and in great detail!</p>
<p>It just lacks the “put it all together” part most of the time.</p>
</blockquote>
<h2 id="ok-what-do-we-need">Ok, what do we need?</h2>
<p>A good first question indeed: what information do we need to store?</p>
<p>A chess position is represented by:</p>
<ul>
<li>the position of pieces on the board.</li>
<li>which player’s turn it is.</li>
<li><a href="https://en.wikipedia.org/wiki/Castling">castling rights</a>.</li>
<li><a href="https://en.wikipedia.org/wiki/En_passant">en passant</a> target square.</li>
</ul>
<blockquote>
<p>There are also a few more metadata fields needed, like keeping track of
<a href="https://en.wikipedia.org/wiki/Threefold_repetition">repetitions</a> or the
<a href="https://en.wikipedia.org/wiki/Fifty-move_rule">fifty-move rule</a>, but they’re not that relevant here.</p>
</blockquote>
<p>We also need to know <strong>how</strong> these informations will be used. Actions in chess are moves. We need
to be able to know which moves we can make, and how to modify the position’s data to go
back and forth between positions given a move.</p>
<p>These will be our three main functions:</p>
<ul>
<li><code class="sourceCode rust"><span class="kw">fn</span> make(p<span class="op">:</span> Position<span class="op">,</span> m<span class="op">:</span> Move)</code> modifies the position as if we played the given move.</li>
<li><code class="sourceCode rust"><span class="kw">fn</span> unmake(p<span class="op">:</span> Position<span class="op">,</span> m<span class="op">:</span> Move)</code> resets the position state to what it was before making a move.</li>
<li><code class="sourceCode rust"><span class="kw">fn</span> moves(p<span class="op">:</span> Position) <span class="op">-&gt;</span> [Move]</code> creates a list of legal moves for a given position.</li>
</ul>
<blockquote>
<p>We could choose to generate <strong>pseudo-legal moves</strong>, which follow the rules of chess, but might leave the king in check.</p>
<p>Those moves are invalid, which means that we need to check whether they leave
the king in check after making them and undoing the move if it’s the case.</p>
<p>Most of the time, this is <strong>slower</strong> than embedding more checks into the move generation code,
so we’ll generate only legal moves.</p>
</blockquote>
<h2 id="encoding-our-chess-board">Encoding our chess board</h2>
<p>I’ll be keeping this part brief: <strong>try to compress your representation</strong>. Using
the cache efficiently is incredibly important for chess engines.</p>
<p>Applying this, here’s a good and pretty standard way to store moves and piece types:</p>
<figure>
<img src="/files/writing-an-efficient-game-representation-for-chess/encoding_pieces.png" data-max-height="20em" alt="Encoding for pieces and moves" />
<figcaption aria-hidden="true">Encoding for pieces and moves</figcaption>
</figure>
<blockquote>
<p>The “flags” part of the move encoding is taken straight from <a href="https://www.chessprogramming.org/Encoding_Moves">this page</a></p>
</blockquote>
<p>As for the actual board, there are two ways to go about it: <strong>piece</strong> or <strong>square</strong> centric.
The former keeps information of where pieces are, while the latter
keeps information of what is on a given square.</p>
<figure>
<img src="/files/writing-an-efficient-game-representation-for-chess/square_piece.png" data-max-height="15em" alt="Diagram comparing piece and square centric representations" />
<figcaption aria-hidden="true">Diagram comparing piece and square centric representations</figcaption>
</figure>
<ul>
<li><strong>Piece centric</strong> representations are faster when iterating over pieces (in move generation
for example) because they avoid constantly checking “is there even a piece here?”.</li>
<li><strong>Square centric</strong> representations are faster at answering “which piece is on this square?”,
which can be useful when making and unmaking moves.</li>
</ul>
<p>Therefore, most engines nowadays say… <strong>“why not both?”</strong>. This wastes a bit of
space, and we get redundant information, but it’s way faster to query said information
when needed!</p>
<p>My board representation combines an 8x8 array of <code class="sourceCode rust"><span class="dt">Option</span><span class="op">&lt;</span>PieceKind<span class="op">&gt;</span></code> with
a piece-centric representation known as <a href="https://en.wikipedia.org/wiki/Bitboard">bitboards</a>.</p>
<h3 id="bitboards-101">Bitboards 101</h3>
<p>A bitboard can be thought of as a set of elements that can be indexed, with the bit at
index <span class="math inline"><em>n</em></span> set to <span class="math inline">1</span> if the <span class="math inline"><em>n</em><sup><em>t</em><em>h</em></sup></span> element is present and <span class="math inline">0</span> otherwise.</p>
<p>The cool thing about applying this to chess boards is that <strong>we have 64 squares</strong>, and can
therefore store this set information in a <strong>64 bit integer</strong>.</p>
<p>The crux of the idea is to store one bitboard per piece kind and one bitboard per color.
We can then do setwise operations in <strong>a single instruction</strong>.</p>
<p>For example, say we want to get a bitboard of white pawns. Well, this translates to:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> white_pawn_bitboard <span class="op">=</span> pawn_bitboard <span class="op">&amp;</span> white_bitboard</span></code></pre></div>
<figure>
<img src="/files/writing-an-efficient-game-representation-for-chess/bitboard_example.png" data-max-height="30em" alt="Bitboard usage example" />
<figcaption aria-hidden="true">Bitboard usage example</figcaption>
</figure>
<p>This becomes particularily useful when applying shifts, or filtering attackable/movable
squares, as we’ll see in a minute.</p>
<p>An important idea of bitboards is <strong>serializing</strong>. When we get a bitboard of target
squares, we cannot transform it into a list of moves directly. We first need to
<strong>extract the information</strong> of which squares are set.</p>
<p>The main way to do it is to find the lowest set bit of the bitboard, then resetting
said bit. Keep going until the bitboard is empty and <strong>boom</strong>, a list of indices of
set bits! Yay!</p>
<p>Here’s what this would look like in crude pseudo-code:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> serialize(bitboard<span class="op">:</span> Bitboard) <span class="op">-&gt;</span> <span class="dt">Vec</span><span class="op">&lt;</span>Square<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">mut</span> indices <span class="op">=</span> <span class="pp">vec!</span>[]<span class="op">;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">!</span>bitboard<span class="op">.</span>is_empty() <span class="op">{</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> square <span class="op">=</span> bitboard<span class="op">.</span>pop_lowest_square()<span class="op">;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    bitboard<span class="op">.</span>reset_lowest_square()<span class="op">;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    indices<span class="op">.</span>push(square)<span class="op">;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  indices</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In reality, a better way to implement this is as an iterator, which would look like
this in Rust:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> <span class="bu">Iterator</span> <span class="cf">for</span> Bitboard <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> Item <span class="op">=</span> Square<span class="op">;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fn</span> next(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">Option</span><span class="op">&lt;</span>Square<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">self</span><span class="op">.</span>is_empty() <span class="op">{</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>      <span class="cn">None</span> <span class="co">// If the board is empty, we stop</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> square <span class="op">=</span> bitboard<span class="op">.</span>trailing_zeros()<span class="op">;</span> <span class="co">// Same as finding the lowest set bit</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>      bitboard <span class="op">&amp;=</span> bitboard <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Efficiently reset the lowest set bit</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>      <span class="cn">Some</span>(square)</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>We can now iterate over set square on our bitboard, which is useful for applying all
kinds of transformations!</p>
<h2 id="generating-moves">Generating moves</h2>
<p>Now we move on to the interesting part: <strong>how can we use that to generate moves?</strong> I’ll first present general techniques without caring about legality. We’ll handle that afterwards!</p>
<h3 id="pawns">Pawns</h3>
<p>Pawns are really benefitting from the bitboard representation. We start by filtering pawns
which are about to promote, separating them from the rest:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pawns <span class="op">=</span> pawn_bitboard <span class="op">&amp;</span> side_to_move_bitboard<span class="op">;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> promoting_pawns <span class="op">=</span> pawns <span class="op">&amp;</span> promoting_rank<span class="op">;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pawns <span class="op">=</span> pawns <span class="op">^</span> promoting_pawns<span class="op">;</span></span></code></pre></div>
<p>We can than generate pawn moves by <strong>shifting the entire bitboard</strong> in different directions.</p>
<figure>
<img src="/files/writing-an-efficient-game-representation-for-chess/shift_example.png" data-max-height="20em" alt="We shift the bitboard in the north direction, moving all bits to the next rank. This represents our pawn pushes!" />
<figcaption aria-hidden="true">We shift the bitboard in the north direction, moving all bits to the next rank. This represents our pawn pushes!</figcaption>
</figure>
<p>However, we’re not done here: what if there are already pieces on the squares we want to
get to? <strong>Pawns can’t capture by moving forward!</strong></p>
<p>Well, we can mask this <code>pawn_pushes_bitboard</code> by an <code>empty</code> bitboard that contains
set bits wherever there are no pieces. This bitboard can be obtained by negating the union
of our two color bitboards, pretty neat!</p>
<figure>
<img src="/files/writing-an-efficient-game-representation-for-chess/blockers_example.png" data-max-height="20em" alt="Taking an arbitraty empty bitboard, here’s what would happen." />
<figcaption aria-hidden="true">Taking an arbitraty empty bitboard, here’s what would happen.</figcaption>
</figure>
<p>I’m not going to detail everything here, but the same ideas can be applied
for all pawn movements. You generate a set of potential target squares, then mask
it by squares that can actually be moved to (empty ones for pushes, enemy pieces for captures, en passant target for en passant captures, etc).</p>
<h3 id="knights-and-kings">Knights and kings</h3>
<p>Knights and kings are different from pawns: there are a looot of deltas that can be applied,
and most of the time only two knights and one king. We don’t benefit much from parallelization
here.</p>
<p>Instead, we can calculate a lookup table of potential moves for each origin square!
We could then access the moves for a knight on d5 this way:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> knight_moves <span class="op">=</span> KNIGHT_LOOKUP[<span class="pp">Square::</span>D5]<span class="op">;</span></span></code></pre></div>
<figure>
<img src="/files/writing-an-efficient-game-representation-for-chess/lookup_knight.png" data-max-height="20em" alt="Example of knight moves from the d5 square." />
<figcaption aria-hidden="true">Example of knight moves from the d5 square.</figcaption>
</figure>
<p>There’s not much going on for knights and kings (<em>for now</em>) appart from that, they’re pretty simple!</p>
<h3 id="sliding-pieces">Sliding pieces</h3>
<p><em>Uh oh…</em></p>
<p>Sliding pieces (bishops, rooks and queens) are a bit more tricky. The main difficulty
is the fact that their moves can be thought of as rays that can be blocked by
other pieces! We can’t simply create a lookup table associating an attack bitboard from
each square like knights and kings, since we also depend on the state of the board.</p>
<p>There are two (main) ways to go about things:</p>
<ul>
<li>calculating the attacks using fill algorithms on bitboards (<a href="https://www.chessprogramming.org/Dumb7Fill">Dumb7Fill</a>, <a href="https://www.chessprogramming.org/Kogge-Stone_Algorithm">Kogge-Stone</a> or <a href="https://www.chessprogramming.org/Fill_by_Subtraction">Fill by subtraction</a> are good examples).</li>
<li>creating lookup tables indexed by square <strong>and blockers</strong>.</li>
</ul>
<p>We’ll be focusing on the latter since it is often faster on modern CPUs with big caches.
More precisely, we’ll be looking at <a href="https://www.chessprogramming.org/Magic_Bitboards">magic bitboard</a>.</p>
<blockquote>
<p>There are other ways to create lookup tables, which I’ll mention briefly:</p>
<ul>
<li><a href="https://www.chessprogramming.org/Rotated_Bitboards">rotated bitboards</a> cover line attacks only, and require additionnal bitboards updated incrementally to work efficiently.</li>
<li><a href="https://www.chessprogramming.org/Kindergarten_Bitboards">kindergarten bitboard</a> require some more calculation. They are a good middle ground between pure lookup and pure calculation!</li>
</ul>
<p>The main advantage of magic bitboards is that they cover rook and bishop attacks (two lines)
at once rather than a single line each time.</p>
</blockquote>
<p>What we’re trying to find is a <a href="https://en.wikipedia.org/wiki/Perfect_hash_function">perfect hash function</a>
from blockers to attacks for each square. If this seems like a complex endeavour, you’d
be right! Thankfully, smarter folks have already thought about it for us.</p>
<p>First of all, we don’t want to perfectly hash <em>all possible blocker setups</em>. Taking a
bishop on e4, it doesn’t matter to us wether a piece is on d2: we wouldn’t cross it
anyway.</p>
<p>What we want is, once again, to <strong>mask relevant blockers</strong> and use this as a key. Already, we’ve
simplified our search quite a bit!</p>
<figure>
<img src="/files/writing-an-efficient-game-representation-for-chess/relevant_blockers.png" style="height:40em" alt="Computing relevant blockers for a bishop on c4." />
<figcaption aria-hidden="true">Computing relevant blockers for a bishop on c4.</figcaption>
</figure>
<p>Now, we’ve got a little problem… <em>how do we transform our relevant blockers into a unique key?</em></p>
<p>Well, folks, I present to you the solution to any complex problem: <strong>brute-force!</strong></p>
<p>Yup, you’ve heard that right, what we’re going to find is a <strong>magic number</strong> (thus the name)
that, when multiplied with our bitboard and then shifted by a number of bits <span class="math inline"><em>n</em></span> (often the number of relevant blockers)
perfectly maps blockers to the correct set of attacked square.</p>
<p>There is a <a href="https://analog-hors.github.io/site/magic-bitboards/">great article by Analog Hors</a> on
the process of computing and using said magic numbers, so I won’t delve into it too deeply.
Just remember that we have a function that, given an origin square and a set of blockers,
returns the squares attacked by a bishop/rook on said origin square.</p>
<blockquote>
<p>There are <strong>a lot</strong> of improvements for magic bitboards. Some are <a href="https://www.chessprogramming.org/BMI2#PEXTBitboards">dependant on
specific hardware instructions</a>,
others are implemented using more advanced hashing functions.</p>
<p>There are also improvements to be made on <strong>magic numbers themselves</strong>. There is
an ongoing effort to <a href="https://www.chessprogramming.org/Best_Magics_so_far">find magic numbers requiring less bits</a>,
which reduces the space required to store our informations.</p>
<p>As mentionned before, small gains get more and more negligeable past a certain point.
Magic bitboards are more than sufficient for now, and the small improvements granted
by more advanced implementations tend to get negligeable within an engine, so I won’t
talk about them here.</p>
<p>Still, it’s a depply interesting ~rabbit hole~ topic to dive into if you’ve got
time to dedicate to it! Current magic numbers are <a href="https://www.chessprogramming.org/Magic_Bitboards#Wishing_Dreams">a bit wasteful</a>,
so maybe you’ll be the one to find better ones, who knows?</p>
</blockquote>
<p>So how do we use this? Well, similar to knights and kings, we iterate over all
sliding pieces and lookup what moves they can make!</p>
<p>A quick heads up: it is faster to separate between <strong>diagonal sliders</strong> (bishops and queens)
and <strong>orthogonal sliders</strong> (rooks and queens). This way, our lookups are easier to encode.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Iterate over our bishops and queens</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> origin <span class="kw">in</span> diagonal_sliders <span class="op">{</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Lookup our moves from the magic table</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> moves <span class="op">=</span> diagonal_moves(origin<span class="op">,</span> <span class="op">!</span>empty)<span class="op">;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Then generate captures and quiet moves</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> target <span class="kw">in</span> moves <span class="op">&amp;</span> ennemy_pieces <span class="op">{</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Some move encoding stuff for captures</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> target <span class="kw">in</span> moves <span class="op">&amp;</span> empty <span class="op">{</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Some move encoding for quiet moves</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="that-was-an-illegal-left-by-the-way">“That was an illegal left by the way”</h3>
<p>Okay, okay, let’s make sure our moves are legal now!</p>
<p>First, let’s see… Which of our generated moves <em>could be</em> illegal?
Well, there are a few:</p>
<ul>
<li>moves of a piece that would leave the king in check. Such pieces are called <a href="https://en.wikipedia.org/wiki/Pin_(chess)">absolutely pinned</a> and cannot move except along the ray that pins them to the king.</li>
<li>en passant captures can, in specific cases, leave the king in check by making two pawns disappear on the same rank.</li>
<li>moves other than the king’s if it is checked by two or more pieces.</li>
<li>if the king is checked by a single piece, moves that do not capture the checking piece or block the attack ray.</li>
<li>in general, king moves to attacked squares.</li>
<li>castling over attacked squares.</li>
</ul>
<figure>
<img src="/files/writing-an-efficient-game-representation-for-chess/illegal_moves.png" style="height:20em" alt="Some situations that create illegal moves (in red)" />
<figcaption aria-hidden="true">Some situations that create illegal moves (in red)</figcaption>
</figure>
<p><em>Phew</em>, okay, how do we deal with that?</p>
<h4 id="pins-checks-and-attacks">Pins, checks and attacks</h4>
<p>Three informations are clearly of importance here:</p>
<ul>
<li>whether the king is in check, and if so, does more than one piece attack it?</li>
<li>which pieces are pinned, and where can they move?</li>
<li>which squares are attacked?</li>
</ul>
<p>This all depends on moves that the ennemy pieces can make! We don’t want to generate
every move for every ennemy piece tho, that would just double our workload and is unnecessary.</p>
<p>What we’ll do instead is compute three bitboards:</p>
<ul>
<li>attacked squares.</li>
<li>checking piece(s).</li>
<li>pieces of the moving side which are not pinned.</li>
</ul>
<p>This is done by generating attack targets (not actual moves, the distinction is important)
for all ennemy pieces.</p>
<blockquote>
<p>Some game representations separate the routine of <strong>detecting pins</strong>, <strong>generating moves
for pinned pieces</strong> and <strong>generating attacked squares</strong>.</p>
<p>Most of the time, it is more efficient to do all three in one pass, since they all
reuse information from one another. It is less readable and more error prone, but
worth it in the end!</p>
</blockquote>
<p>Pawns, knights and kings cannot create pins. This makes it easier to deal with them:
just generate their attack targets and add them to the bitboard of attacked squares.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>attacked_squares <span class="op">|=</span> KING_LOOKUP[ennemy_king]<span class="op">;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> knight <span class="kw">in</span> ennemy_knights <span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  attacked_squares <span class="op">|=</span> KNIGHT_LOOKUP[knight]<span class="op">;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="co">// Same for pawns</span></span></code></pre></div>
<p>If at this point the attack bitboard intersects with our king bitboard, we’re in check!
We generate attacks from our king, and intersect them with ennemy pawns/knights, then add
the result to the checking pieces’ bitboard.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> attacked_squares <span class="op">&amp;</span> allied_king <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  checkers <span class="op">|=</span> KNIGHT_LOOKUP[allied_king] <span class="op">&amp;</span> ennemy_knights<span class="op">;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Same for pawns</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<blockquote>
<p>I’ve left out the ennemy king in that last part. The reason is that it cannot ever
check our own king, otherwise we’d already be in an illegal position.</p>
</blockquote>
<p>Now we get to the fun part: <strong>sliders</strong>.</p>
<p>First, the attack bitboard. One may think that simply looking up magic bitboards as
we usually do would work, but this leads to a sneaky bug: <strong>our king could slide away from a check</strong>.</p>
<figure>
<img src="/files/writing-an-efficient-game-representation-for-chess/slide_away.png" style="height:20em" alt="Example where using the king as a blocker is incorrect: we could generate a move to the north, which would still leave us in check." />
<figcaption aria-hidden="true">Example where using the king as a blocker is incorrect: we could generate a move to the north, which would still leave us in check.</figcaption>
</figure>
<blockquote>
<p>You might notice that some squares here are not <em>actually attacked</em>. So is our attack bitboard
wrong?</p>
<p>Well, if we’re asking for a set of actually attacked squares, yes, it is wrong.
But we’re only interested in squares our king cannot move to <strong>or</strong> squares that we cannot
castle through. Here, both are valid.</p>
</blockquote>
<p>Other than that, generating the attack map has no weird intricacies, so we’re done here:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Example for diagonal sliders</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> origin <span class="kw">in</span> diagonal_sliders <span class="op">{</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  attacked_squares <span class="op">|=</span> diagonal_moves(origin<span class="op">,</span> blockers <span class="op">&amp;</span> <span class="op">!</span>king)<span class="op">;</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">// (rest of the code for handling pins and checks...)</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>But, as we said above, we want to generate moves for pinned pieces and detect checks
while we have this attack information as well!</p>
<p>Checks are easy to detect: we just need to assert whether the attack rays intersect
with our king. If it does, bing bong, you’re in check! The piece is added to the bitboard of
checkers as usual.</p>
<p>On top of that, we generate a ray along which our pieces can move
to block the check. The way I do it is by generating corresponding slider moves <strong>originating
from our king</strong> and <strong>bypassing our pieces</strong>. The intersection of those attacks and the
attacking piece moves will give us our attack ray!</p>
<figure>
<img src="/files/writing-an-efficient-game-representation-for-chess/pin_ray.png" style="height:20em" alt="The pin ray that we discover." />
<figcaption aria-hidden="true">The pin ray that we discover.</figcaption>
</figure>
<p>This ray from our king can <strong>also be used to detect pins</strong>. If the king attack intersects
with a corresponding ennemy slider, we simply need to count how many of our pieces
intersect with the pin ray.</p>
<blockquote>
<p>The additionnal lookups for crafting the actual ray <strong>must be</strong> guarded by a
conditional! Otherwise, they can be pretty damn costly.</p>
</blockquote>
<p>If there is only one, it is pinned. At this point, we can generate moves <strong>only if
they target the pin ray</strong>.</p>
<p>We then must carefully remove the pinned piece from normal move generation. This is done
by adding it to the pinned pieces bitboard, which we’ll use as a mask over our pieces
in the rest of the move generation.</p>
<h4 id="adapting-the-rest-of-move-generation">Adapting the rest of move generation</h4>
<p>Let’s sum up the modifications we made. We have access to:</p>
<ul>
<li>a bitboard of allied pieces which are not pinned.</li>
<li>a bitboard of checking pieces.</li>
<li>a set of squares that pieces can move to.</li>
<li>a bitboard of attacked squares.</li>
</ul>
<p>First, we’ll differentiate between our 3 cases: the king can be in <strong>single check</strong>, <strong>double check</strong>, or <strong>not attacked</strong>.
We can find this information by counting the number of checking pieces.</p>
<ul>
<li>if there are no checkers, we change the set of squares that pieces can move to to be empty squares, and change the set of squares we can capture to squares where there are ennemy pieces. We also generate castling moves if applicable.</li>
<li>if there is at least one checker, we need to clear up potential pinned piece moves generated previously since they are not legal anymore.</li>
<li>past two checking pieces, we skip generating moves for general pieces and only generate king moves.</li>
</ul>
<div class="sourceCode" id="cb10"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> checkers_count <span class="op">=</span> checkers<span class="op">.</span>count_ones()<span class="op">;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> checkers_count <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Change our quiet moves and captures targets.</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  movable <span class="op">=</span> empty_squares<span class="op">;</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  capturable <span class="op">=</span> ennemy_pieces<span class="op">;</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Generate castling moves.</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>  generate_castling_moves()<span class="op">;</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Clear up previously generated moves for pinned pieces.</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>  moves<span class="op">.</span>clear()</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> checkers_count <span class="op">&lt;</span> <span class="dv">2</span> <span class="op">{</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Generate moves for other pieces</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a><span class="co">// Generate king moves</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> king_moves <span class="op">=</span> KING_LOOKUP[king_square] <span class="op">&amp;</span> <span class="op">!</span>attacked_squares<span class="op">;</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span></code></pre></div>
<p>The only thing that changes for the king is that we mask its potential moves not only
with the usual empty squares/ennemy pieces, but also by <strong><code class="sourceCode rust"><span class="op">!</span>attacked_squares</code></strong></p>
<h4 id="problem-en-passant-discovered-check">Problem: en passant discovered check</h4>
<figure>
<img src="/files/writing-an-efficient-game-representation-for-chess/pin.png" style="height:20em" alt="Remember this problematic position?" />
<figcaption aria-hidden="true">Remember this problematic position?</figcaption>
</figure>
<p>Well, it’s time to deal with it now! We’ll also take time to actually deal with en passant
captures after delaying that for most of this post.</p>
<blockquote>
<p>En passant captures are hell and I despise them from the bottom of my heart. Chess
is generally pretty smooth when it comes to its rules, and then they throw this random,
once in a blue moon move that is hard to deal with when programming!</p>
</blockquote>
<p>Our main problem is the fact that capturing en passant can <strong>discover a check on the king</strong> even
tho the pawn isn’t pinned!</p>
<p>The advantage of en passant tho is that it is <strong>extremely rare</strong>, so generating en passant
moves a bit slowly is not that bad and we can focus on correctness.</p>
<p>What we need to do is identify the captured square, the capturer, and check if an orthogonal
ray from our king following the rank the en passant capture happens on, removing both
the captured and capturer from the blockers bitboard, reaches a queen or rook.</p>
<blockquote>
<p>At first, I had an additionnal check for discovered checks from bishops, in such positions
for example:</p>
<figure>
<img src="/files/writing-an-efficient-game-representation-for-chess/non_problem.png" style="height:20em" alt="Capturing the pawn en passant would discover an attack on our king! Oh… no?" />
<figcaption aria-hidden="true">Capturing the pawn en passant would discover an attack on our king! Oh… no?</figcaption>
</figure>
<p>In reality, such positions <strong>cannot happen after a series of legal moves</strong>. The reason is that
there are only two ways we can get into such a position:</p>
<ul>
<li>either the pawn just moved, and therefore the bishop was already checking our king, which cannot be legal.</li>
<li>or the bishop just moved, and therefore the pawn cannot be captured en passant anymore.</li>
</ul>
</blockquote>
<h2 id="general-performance-tips">General performance tips</h2>
<p>Sadly, this last “implementation” section will be reaaaally specific to Rust, since that’s the language
I’m using to implement this move generator. Still, you might find ways to apply those
tips in other languages!</p>
<h3 id="generic-functions">Generic functions</h3>
<p>Move generation is dependant on which side is currently moving. Things like the
directions pawns move towards, ennemy pieces, etc.</p>
<p>You could do all of that with a bunch of <code class="sourceCode rust"><span class="cf">if</span></code> statements and pray that the
branch prediction gods are on your side (they often are), but a little nudge in the
right direction certainly helps!</p>
<p>One way to do so is to pack two side-specific functions (one for white, one for black)
and choose between them at the start of move generation. Writing two functions is
just a way to ~create more bugs~ duplicate logic, so we instead use Rust’s <strong>const generics</strong>.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> moves(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">Vec</span><span class="op">&lt;</span>Move<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fn</span> moves_generic<span class="op">&lt;</span><span class="kw">const</span> BLACK_TO_MOVE<span class="op">:</span> <span class="dt">bool</span><span class="op">&gt;</span>(position<span class="op">:</span> <span class="op">&amp;</span>Position) <span class="op">-&gt;</span> <span class="dt">Vec</span><span class="op">&lt;</span>Move<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Logic goes here</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="kw">self</span><span class="op">.</span>black_to_move <span class="op">{</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="pp">moves_generic::</span><span class="op">&lt;</span><span class="cn">true</span><span class="op">&gt;</span>(<span class="kw">self</span>)</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    <span class="pp">moves_generic::</span><span class="op">&lt;</span><span class="cn">false</span><span class="op">&gt;</span>(<span class="kw">self</span>)</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>You can then use the <code class="sourceCode rust">BLACK_TO_MOVE</code> constant within the inner function, and
Rust will actually generate the two specific functions during compilation!</p>
<h3 id="trust-our-benevolent-branch-predictor">Trust our benevolent branch predictor</h3>
<p>Going the exact opposite of what has been said above: trust branch prediction!</p>
<p>If you have work that is tedious and unlikely to be required, <strong>put it in a branch</strong>.
Generic functions can only go so far, and there are some things that cannot be known
statically.</p>
<p>For example, querying the magic bitboards a second time to generate rays for pinned pieces
is unlikely to be necessary. Putting it under a conditional saves time!</p>
<h3 id="use-the-stack-dammit">Use the stack, dammit!</h3>
<p>Storing our generated moves in a <code class="sourceCode rust"><span class="dt">Vec</span><span class="op">&lt;</span>Move<span class="op">&gt;</span></code> is <strong>sloooooooooow</strong>… Thankfully,
Rust provides some <sub>libraries</sub> crates for stack vectors (which are just fixed size arrays
where not every element is initialized, adding some <code class="sourceCode rust">push</code> and other nice APIs).</p>
<p>The example I’m using is called <a href="https://docs.rs/arrayvec/latest/arrayvec/">arrayvec</a>,
allowing me to avoid recoding one myself. Yay, lazyness!</p>
<h3 id="iterators-trust-me-theyre-optimized">Iterators! Trust me, they’re optimized</h3>
<p>When serializing moves, you might want to use iterators <strong>a lot</strong>. More notably the
<code class="sourceCode rust">extend</code> function, which lets you add the elements of an iterator in a collection all at once.</p>
<p>The advantage over a for loop is that if you know the size of your iterator (as we do
here, since we can just call <code>count_ones</code> on our bitboards of target squares), the collection
will grow only once, and then everything will be pushed without incrementing the
lenght each time.</p>
<blockquote>
<p>This information is given to the compiler by implementing the
<a href="https://doc.rust-lang.org/std/iter/trait.ExactSizeIterator.html"><code class="sourceCode rust"><span class="bu">ExactSizeIterator</span></code></a>
trait.</p>
</blockquote>
<p>Basically, it allows you to do everything in a batch! This saves a bunch of precious
operations during move generation.</p>
<p>Generally speaking, Rust’s iterators are <strong>really optimal</strong>, so
it’s always a good idea to rewrite for loops using them to see if it improves your
performance.</p>
<blockquote>
<p>The “checking” part is thoroughly important, and I cannot emphesize this enough!
Sometimes, for loops are faster, you can’t know unless you try and benchmark the change.</p>
<p>For example, <code class="sourceCode rust">chain</code> or <code class="sourceCode rust">flat_map</code> make performance worse, because
they never implement the <code class="sourceCode rust"><span class="bu">ExactSizeIterator</span></code> trait that our optimization relies on!</p>
</blockquote>
<h2 id="so-is-this-even-correct">So, is this even correct?</h2>
<p>Welp, I’m a computer scientist at heart so my answer will be: <strong>I don’t know</strong>… but
I can still be <strong>highly confident</strong> that <strong>it is correct</strong>!</p>
<p>The main method of testing for game representations is <a href="https://www.chessprogramming.org/Perft">perft</a>.
The idea is to walk the game tree, counting how many nodes are accessible up to a certain
depth. <a href="https://www.chessprogramming.org/Perft_Results">Results for chess</a> have been
thoroughly discussed and validated by many many people, so we can be pretty confident that
they are correct.</p>
<p>Thus, we simply have to check that our game representation outputs the same number
of reachable positions! Easy!</p>
<blockquote>
<p>The reason I’m saying that I’m not certain that my game representation is correct
is because those results aren’t in any way proven.</p>
<p>One way to be absolutely certain, 100%, that those numbers are correct would be to
create a <a href="https://en.wikipedia.org/wiki/Formal_verification">formally verified</a>
game representation using tools like <a href="https://coq.inria.fr/">Coq</a> or <a href="https://hackage.haskell.org/package/Agda">Agda</a>.
This could be a fun project someday, but it waaaaay out of the
scope of this already too long post!</p>
</blockquote>
<p>Aaaand… guess what? It seems we’re good to go!</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ex">~/D/chameleon-chess</span> <span class="op">&gt;</span> target/release/perft <span class="at">-bip</span> 8</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="ex">r</span> n b q k b n r</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="ex">p</span> p p p p p p p</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="bu">.</span> . . . . . . . side to move: white</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="bu">.</span> . . . . . . . reversible moves: 0</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="bu">.</span> . . . . . . . en passant: <span class="at">-</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="bu">.</span> . . . . . . . castling rights: KQkq</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="ex">P</span> P P P P P P P hash: 0x1f5ca3327330cf5e</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="ex">R</span> N B Q K B N R</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a><span class="ex">depth</span> 1: 20 nodes</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a><span class="ex">depth</span> 2: 400 nodes</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a><span class="ex">depth</span> 3: 8902 nodes</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a><span class="ex">depth</span> 4: 197281 nodes</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a><span class="ex">depth</span> 5: 4865609 nodes</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a><span class="ex">depth</span> 6: 119060324 nodes</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a><span class="ex">depth</span> 7: 3195901860 nodes</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a><span class="ex">depth</span> 8: 84998978956 nodes</span></code></pre></div>
<blockquote>
<p>I’ve tested the code on <a href="https://www.chessprogramming.org/Perft_Results">other positions</a> as well,
with all positions correct up to decent depths!</p>
</blockquote>
<h2 id="and-how-fast-is-it-three-fasts-four-fasts">And how fast is it? Three fasts? FOUR FASTS???</h2>
<p>Perft is also a good way to compare the speed of game representations, since it
makes use of every function we’ve defined so far!</p>
<p>We’ll make a little contest, comparing my game representation to
<a href="https://home.hccnet.nl/h.g.muller/dwnldpage.html">QPerft</a>.
The former uses a square-centric board representation and is deemed the baseline against
which most engines compare their game representation. In the [mailbox trials], it was
deemed comparable in speed to <a href="https://github.com/official-stockfish/Stockfish">Stockfish</a>’s bitboard representation.</p>
<blockquote>
<p>I planned on including Stockfish itself to this comparison at first. The thing is, recent
Stockfish implementations include an <a href="https://en.wikipedia.org/wiki/Efficiently_updatable_neural_network">NNUE</a>, which
slows it down <strong>dramatically</strong>.</p>
<p>Simply put, it wouldn’t have been fair to compare two game representations made
specifically for the perft test against one that embeds a full neural network in
its game representation!</p>
</blockquote>
<p>For reference, the benchmarking setup involved running each of the usual perft positions on
each competing program. This is done using <a href="https://github.com/sharkdp/hyperfine">hyperfine</a>.
The code ran on an AMD Ryzen 5 5500U, in single core iterative perft with bulk-counting
on horizon nodes.</p>
<p><strong>Here are the fabled results:</strong></p>
<table style="width:100%;">
<colgroup>
<col style="width: 13%" />
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 11%" />
<col style="width: 12%" />
<col style="width: 13%" />
<col style="width: 13%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;"><strong>start</strong> (7)</th>
<th style="text-align: center;"><strong>kiwipete</strong> (6)</th>
<th style="text-align: center;"><strong>endgame</strong> (8)</th>
<th style="text-align: center;"><strong>mirrored</strong> (6)</th>
<th style="text-align: center;"><strong>talkchess</strong> (5)</th>
<th style="text-align: center;"><strong>alternative</strong> (6)</th>
<th style="text-align: center;"><strong>mean</strong> (deviation)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>chameleon-perft</strong></td>
<td style="text-align: center;">12.662s (252Mnps)</td>
<td style="text-align: center;">24.432s (329Mnps)</td>
<td style="text-align: center;">13.212s (228Mnps)</td>
<td style="text-align: center;">2.103s (336Mnps)</td>
<td style="text-align: center;">0.274s (328Mnps)</td>
<td style="text-align: center;">20.773s (333Mnps)</td>
<td style="text-align: center;">301Mnps (~47.9)</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>qperft</strong></td>
<td style="text-align: center;">12.612s (253Mnps)</td>
<td style="text-align: center;">33.286s (241Mnps)</td>
<td style="text-align: center;">23.310s (129Mnps)</td>
<td style="text-align: center;">4.354s (162Mnps)</td>
<td style="text-align: center;">0.502s (179Mnps)</td>
<td style="text-align: center;">18.519s (374Mnps)</td>
<td style="text-align: center;">223Mnps (~87.8)</td>
</tr>
</tbody>
</table>
<p>Damn, that’s <strong>pretty efficient!</strong> We beat or equalize with QPerft on almost every position!!! It’s safe
to say that our game representation is good enough at this point.</p>
<blockquote>
<p>Note that this happens on <strong>my specific</strong> CPU, results may vary dependending on
architecture, instruction set, etc.</p>
<p>This is especially true for bitboard representations, which rely on bit tricks
and lower level instructions. For example, if your CPU has a slow “trailing ones”
instruction (or none at all), bitboard serialization takes a serious hit!</p>
</blockquote>
<h2 id="whats-next">What’s next?</h2>
<p>We’ve got ourselves a <strong>really nice</strong> game representation, so there are only a few things left to do:</p>
<ul>
<li>use it in an actual, complete chess engine (notably embedding it into <code>chameleon</code>, a general game playing framework that I’m developping on the side).</li>
<li>procrastinate by implementing more complex magic bitboards schemes, since <a href="https://www.chessprogramming.org/Magic_Bitboards#Sharing_Attacks">shared attacks</a> look really juicy.</li>
<li>work on actual school projects that are mandatory and on which my future depends (<em>least likely</em>).</li>
</ul>
<p>Anyway, as a thanks for reading this loooooong post, here’s <a href="https://github.com/aloisrtr/chameleon-chess">the repository</a>
where all of the actual code lives!</p>
<p class="head center">
See ya!
</p>]]></description>
    <pubDate>Mon, 12 Feb 2024 00:00:00 UT</pubDate>
    <guid>https://aloisrtr.github.io/thinkingrocks/posts/2024-02-12-writing-an-efficient-chess-move-generator.html</guid>
    <dc:creator>Aloïs Rautureau</dc:creator>
</item>

    </channel>
</rss>
